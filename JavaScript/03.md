# day03

## 其他值到数字值的转换规则

- undefined -> NaN
- Null -> 0
- Boolean: true -> 1, false -> 0
- String: 包含非数字值转换为NaN, 空字符串为0
- Symbol: 不能转换,会报错
- 对象(数组等): 会首先转换为相应的基本数据类型,如果返回时非数字的基本类型值,则再遵守以上规则
- 对于对象一类,转换为基本数据类型,有抽象操作ToPrimitive,检查该值是否有valueOf(返回指定对象的原始值)方法

## 其他值到布尔类型的值的转换规则

假值

- undefined
- null
- false
- +0, -0, NaN
- ''

从逻辑上说,假值以外的都是真值

## {}和[]的valueOf和toString的结果是什么

- {} valueOf: {}, toString: [object Object]
- [] valueOf: [], toString: ''

## 什么是假值对象

假值对象看起来和普通对象并无二致,但将他们强制类型转换为布尔值时的结果为false.最常见的例子时documen.all

## ~操作符的作用

- 按位非: 对任一数值 x 进行按位非操作的结果为 -(x + 1).例如,~5 结果为 -6
- 会将数字转化为32位整数,可以用来取整操作
- 结果会丢失掉小数位,慎用

## 解析字符串中的数字和将字符串强制类型转化为数字的返回结果都是数字,他们之间的区别是什么

- 解析字符串(parseInt等)含有非数字字符也可能转换为数字
- Number一旦出现非数字字符,一定会返回NaN

## + 操作符号什么时候用于字符串的拼接

只要其中一个操作数是字符串

## 什么情况下会发生布尔值的隐式强制类型转换

- if(...)
- for(...;...;)
- while(...) / do..while(...)
- ? :
- || / &&

## || 和 && 操作符的返回值

|| 和 && 返回它们其中一个操作数的值,而非条件判断的结果

## Symbol值的强制类型转换

- 字符串: 允许显式类型转换
- 数字: 显式和隐式都不允许
- 布尔值: 显式和隐式都是true

## == 运算符的强制类型转换规则

- 字符串和数字: 字符串 -> 数字
- 其他类型和布尔类型 布尔 -> 数字
- null和undefined: 结果为真,其他值和他们比较都返回假值
- 对象和非对象: 对象先调用ToPrimitive
- 一个操作值为NaN: 返回false
- 两个都是对象: 是否指向同一个对象

## 如何将浮点数点左边的数每三位添加一个逗号,如 12000000.11 转化为 12,000,000.11

```JavaScript
function format(number) {
  return number && number.replace(/(?!^)(?=(\d{3})+\.)/g, ",");
}
```

## 常用的正则表达式

- Email: `/\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*/`
- URL: `/^https?:\/\/(([a-zA-Z0-9_-])+(\.)?)*(:\d+)?(\/((\.)?(\?)?=?&?[a-zA-Z0-9_-](\?)?)*)*$/i`
- 手机号: `/^(0|86|17951)?(13[0-9]|15[012356789]|166|17[3678]|18[0-9]|14[57])[0-9]{8}$/`

### 一些正则的断言

- x(?=y): 向前断言: x 被 y 跟随时匹配 x
- x(?!y): 向前否定断言: x 没有被 y 紧随时匹配 x
- (?<=y)x: 向后断言: x 跟随 y 的情况下匹配 x
- (?<!y)x: 向后否定断言: x 不跟随 y 时匹配 x

## 生成随机数的各种方法

- Math.random
- Math.floor
- Math.random
- Math.ceil
- 这个四个函数组合排列就可以生成各种所需要的随机数范围

## 如何实现数组的随机排序

- 使用数组 sort 方法对数组元素随机排序，让 Math.random() 出来的数与 0.5 比较，如果大于就返回 1 交换位置，如果小于就返回 -1，不交换位置
- 随机从原数组抽取一个元素，加入到新数组
- 随机交换数组内的元素（洗牌算法类似）

## JavaScript创建对象的几种方式

- 字面量
- 工厂模式
- 构造函数模式
- 原型模式
- 构造函数和原型
- 动态原型
- 寄生构造

## JavaScript继承的几种实现方式

- 原型
- 构造函数

## JavaScript的作用域链

作用域链的作用是保证对执行环境有权访问的所有变量和函数的有序访问,通过作用域链,我们可以访问到外层环境的变量和函数

## 谈谈对This对象的理解

this是执行上下文中的一个属性,它指向最后一次调用这个方法的对象.在实际开发中,this的指向可以通过四种调用模式来判断

- 函数调用模式
- 方法调用模式
- 构造器调用模式
- apply, call和bind

## eval是做什么的

它的功能是把对应的字符串解析成js代码并运行  
应该避免使用eval,不安全,非常消耗性能(2次,一次解析,一次执行)

## 什么是DOM和BOM

- DOM指的是文档对象模型,它指的是把文档当作一个对象来对待,这个对象只要定义了处理网页内容的方法和接口
- BOM指的是浏览器对象模型,它指的是把浏览器当作一个对象来对待,这个对象主要定义了与浏览器进行交互的方法和接口
- window 对象含有 location 对象、navigator 对象、screen 对象等子对象,并且 DOM 的最根本的对象 document 对象也是 BOM 的 window 对象的子对象

## 写下一个通用的事件侦听器函数

```JavaScript

```

## 事件是什么,IE与火狐的事件机制有什么区别,如何阻止冒泡

## 三种事件模型是什么

## 事件委托是什么

## ["1", "2", "3"].map(parseInt) 答案是多少

- `[1, NaN, NaN]`
- 当parseInt的第二个参数为0时,会被认为是十进制

## 什么是闭包,为什么要使用它

- 闭包是指有权访问另一个函数作用域中变量的函数,创建闭包的最常见方式就是在一个函数内创建连另一个函数,创建的函数可以访问到当前函数的局部变量
- 用途一: 可以使我们在函数外部能够访问到函数内部的变量,可以利用这个来创建私有变量
- 用途二: 使已经结束运行的函数上下文中的变量对象继续留在内存中

## JavaScript代码中的'use strict';是什么意思,使用它区别是什么

严格模式,使得JS在更加严格的模式下执行  
主要目的:

- 消除 Javascript 语法的一些不合理、不严谨之处，减少一些怪异行为
- 消除代码运行的一些不安全之处，保证代码运行的安全
- 提高编译器效率，增加运行速度
- 为未来新版本的 Javascript 做好铺垫

区别:

- 禁止使用 with 语句
- 禁止 this 关键字指向全局对象
- 对象不能有重名的属性

## 如何判断一个对象是否属于某个类

## instanceof的作用

instanceof 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上

## new 操作符具体做了什么呢,如何实现

- 首先创建了一个新的空对象
- 设置原型,将对象的原型设置为函数的prototype对象
- 让函数的this指向这个对象,执行构造函数的代码(为这个新对象添加属性)
- 判断函数的返回值类型,如果是值类型,返回创建的对象,如果是应用类型,就返回这个引用类型的对象

## 相对于JSON的了解

## [].forEach.call($$('*'),function(a){a.style.outline="1px solid #"+(~~(Math.random()(1<<24))).toString(16)}) 能解释一下这段代码的意思吗

- 选取页面所有 DOM 元素.在浏览器的控制台中可以使用$$()方法来获取页面中相应的元素,这是现代浏览器提供的一个命令行 API 相当于 document.querySelectorAll 方法
- 循环遍历 DOM 元素
- 给元素添加 outline(外框) .由于渲染的 outline 是不在 CSS 盒模型中的,所以为元素添加 outline 并不会影响元素的大小和页面的布局.
- 生成随机颜色函数.Math.random()*(1<<24) 可以得到 0~2^24 - 1 之间的随机数,因为得到的是一个浮点数,但我们只需要整数部分,使用取反操作符 ~ 连续两次取反获得整数部分,然后再用 toString(16) 的方式,转换为一个十六进制的字符串

## JS延迟加载的方式有哪些

- defer
- async
- 动态创建DOM方式
- 使用setTimeout延迟方法
- 让JS最后加载

## Ajax是什么,如何创建一个Ajax

Ajax: 异步JavaScript和XML,通过JavaScript的异步通信,从服务器获取XML文档中提取数据,再更新当前网页的对应部分,而不用刷新整个网页  
一般而言,Ajax包括以下几个步骤

- 创建一个XMLHttpRequest对象
- 创建一个HTTP请求,并指定HTTP请求的方法,URL及验证信息
- 设置相应的HTTP请求状态变化的函数
- 发送HTTP请求
- 获取异步调用的返回的数据
- 使用JavaScript和DOM实现局部刷新

```JavaScript
let xhr = new XMLHttpRequest()
xhr.open('POST', url, ture)
xhr.setRequestHeader('Content-type', 'application/x-www-form-urlencoded')
xhr.onreadystatechange = () => {
  if(xhr.readyState === 4 && (xhr.status === 200 || xhr.status === 304)) {
    //...
  }
}
xhr.send()
```

## 谈一谈浏览器的缓存机制

- 强缓存策略: Expires, Cache-Control
- 协商缓存策略: Last-Modified <-> If-Modified-Since, Etag

## Ajax解决浏览器的缓存问题

- anyAjaxObj.setRequestHeader('if-Modified-Since', 0)
- anyAjaxObj.setRequestHeader('Cache-Control', 'no-cache')
- URL后面加上一个随机数
- URL后面加上时间戳

## 同步和异步的区别

- 同步就是一步一步执行,必须等每一步的左右操作执行完毕后才会进行下一步
- 而异步就是不用等待每一步执行完成,无论执行完成与否,都会进行下一步操作.而异步的操作在执行完毕后或者在一个恰当的时机会执行设置的回调函数

## 什么是浏览器的同源政策

同源政策就是一个域下的js脚本再未经允许的情况下,不能够访问另一个域的内容,这里的同源指的是域的协议,域名和端口号必须相同,否则不属于同一个域  
同源政策主要限制了三个方面

- 当前域下的js不能访问其他域下的cookie, localStorage和indexDB
- 当前域下的js蹦年操作访问其他域下的DOM
- 当前域下,ajax无法发送跨域请求

同源政策的目的主要是为了保证用户的信息安全,只是对于js的一种限制,并不是对于浏览器的限制.对于一般的img或者script脚本请求都不会有跨域的限制,这是因为这些操作都不会通过相应结果来进行可能出现安全问题的操作

## 如何解决跨域问题

- jsonp
- 图像ping跨域
- CORS
- postMessage
- webpackSocket
- 服务器代理

## 服务器代理转发时,该如何处理cookie

## 简单谈一下cookie

## 模块化开发怎么做

## js的几种模块规范

## AMD和CMD规范的区别

## ES6模块与CommonJS模块,AMD, CMD的差异

## requireJS的核心原理是什么?(如何动态加载,如何避免多次加载,如何'缓存')

## JS模块加载器的轮子怎么造,也就是如何实现要给模块加载器

## ES6怎么写class, 为什么会出现class这种东西

## DOM操作——怎样添加,移除,移动,复制,创建和查找节点

## innerHTML与outerHTML的区别

## JS类数组对象的定义

## 数组和对象有哪些原生方法,列举一下

## 数组的fill方法

## [,,,]的长度

- 答案: 3
- 尾后逗号
- 如果使用了多于一个尾后逗号，会产生间隙。 带有间隙的数组叫做稀疏数组（密致数组没有间隙）。稀疏数组的长度为逗号的数
量

## JavaScript中的作用域与变量声明

## 如何编写高性能的JavaScript

- 使用位运算代替一些简单的四则运算
- 避免使用过深的嵌套循环
- 不要使用未定义的变量
- 当需要多次访问数组长度时,可以用变量保存起来,避免每次都会区进行属性查找

## 简单介绍一下V8引擎的垃圾回收机制

## 使用闭包打印1, 2, 3, 4

## 判断一个对象是否为空对象

- JSON
- for...in
- Object.keys

## 开发中几种常用的Content-Type

- application/x-www-form-urlencoded
- multipart/form-data
- application/json
- text/xml

## require模块引入的查找方式

## 如何封装一个 javascript 的类型判断函数

## 哪些操作会造成内存泄漏

- 意外的全局变量
- 被遗忘的计数器或回调函数
- 脱离DOM的引用
- 闭包

## 移动端的点击事件有延迟,时间时多久,为什么会有,怎么解决这个掩饰
